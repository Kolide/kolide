package kolide

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"time"

	"golang.org/x/crypto/bcrypt"
)

// Datastore combines all the interfaces in the Kolide DAL
type Datastore interface {
	UserStore
	OsqueryStore
	EmailStore
	SessionStore
	Name() string
	Drop() error
	Migrate() error
}

// UserStore contains methods for managing users in a datastore
type UserStore interface {
	NewUser(user *User) (*User, error)
	User(username string) (*User, error)
	UserByID(id uint) (*User, error)
	SaveUser(user *User) error
}

// UserService has methods for working with users
type UserService interface {
	UserStore
	SetPassword(userID uint, password string) error
}

// User is the model struct which represents a kolide user
type User struct {
	ID                 uint `gorm:"primary_key"`
	CreatedAt          time.Time
	UpdatedAt          time.Time
	Username           string `gorm:"not null;unique_index:idx_user_unique_username"`
	Password           []byte `gorm:"not null"`
	Salt               string `gorm:"not null"`
	Name               string
	Email              string `gorm:"not null;unique_index:idx_user_unique_email"`
	Admin              bool   `gorm:"not null"`
	Enabled            bool   `gorm:"not null"`
	NeedsPasswordReset bool
}

type service struct {
	bcryptCost  int
	saltKeySize int
	db          Datastore
}

func (svc service) NewUser(user *User) (*User, error) {
	err := user.setPassword(string(user.Password), svc.saltKeySize, svc.bcryptCost)
	if err != nil {
		return nil, err
	}

	user, err = svc.db.NewUser(user)
	if err != nil {
		return nil, err
	}
	return user, nil
}

func (svc service) User(username string) (*User, error) {
	return svc.db.User(username)
}

func (svc service) UserByID(id uint) (*User, error) {
	return svc.db.UserByID(id)
}

func (svc service) SaveUser(user *User) error {
	return svc.db.SaveUser(user)
}

func (svc service) SetPassword(userID uint, password string) error {
	user, err := svc.UserByID(userID)
	if err != nil {
		return err
	}

	err = user.setPassword(password, svc.saltKeySize, svc.bcryptCost)
	if err != nil {
		return err
	}
	err = svc.SaveUser(user)
	if err != nil {
		return err
	}
	return nil
}

// ValidatePassword accepts a potential password for a given user and attempts
// to validate it against the hash stored in the database after joining the
// supplied password with the stored password salt
func (u *User) ValidatePassword(password string) error {
	saltAndPass := []byte(fmt.Sprintf("%s%s", password, u.Salt))
	return bcrypt.CompareHashAndPassword(u.Password, saltAndPass)
}

func (u *User) setPassword(password string, keySize, cost int) error {
	salt, err := generateRandomText(keySize)
	if err != nil {
		return err
	}
	hashed, err := hashPassword(salt, password, cost)
	if err != nil {
		return err
	}
	u.Salt = salt
	u.Password = hashed
	return nil
}

func hashPassword(salt, password string, cost int) ([]byte, error) {
	withSalt := []byte(fmt.Sprintf("%s%s", password, salt))
	hash, err := bcrypt.GenerateFromPassword(withSalt, cost)
	if err != nil {
		return nil, err
	}
	return hash, nil
}

// generateRandomText return a string generated by filling in keySize bytes with
// random data and then base64 encoding those bytes
func generateRandomText(keySize int) (string, error) {
	key := make([]byte, keySize)
	_, err := rand.Read(key)
	if err != nil {
		return "", err
	}

	return base64.StdEncoding.EncodeToString(key), nil
}
