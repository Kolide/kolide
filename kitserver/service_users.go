package kitserver

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"

	"github.com/kolide/kolide-ose/datastore"
	"github.com/kolide/kolide-ose/kolide"
	"golang.org/x/crypto/bcrypt"
	"golang.org/x/net/context"
)

func (s service) NewUser(ctx context.Context, p kolide.UserPayload) (*kolide.User, error) {
	user, err := userFromPayload(p, s.saltKeySize, s.bcryptCost)
	if err != nil {
		return nil, err
	}
	user, err = s.ds.NewUser(user)
	if err != nil {
		return nil, err
	}
	return user, nil
}

func (s service) User(ctx context.Context, id uint) (*kolide.User, error) {
	// TODO: @groob
	// a user is loaded for almost every request...
	// consider loading the user from an in memory cache for most read operations
	// and possibly only query the DB if the user is being queried for a write operation
	// caching can be done by wrapping the service in a middleware and overriding the read methods.
	return s.ds.UserByID(id)
}

func (s service) Authenticate(ctx context.Context, username, password string) (*kolide.User, error) {
	user, err := s.ds.User(username)
	switch err {
	case nil:
	case datastore.ErrNotFound:
		return nil, authError{
			message: fmt.Sprintf("user %s not found", username),
		}
	default:
		return nil, err
	}
	if err := user.ValidatePassword(password); err != nil {
		return nil, authError{
			message: fmt.Sprintf("unauthorized: invalid password for user %s", username),
		}
	}
	return user, nil
}

func (s service) ChangePassword(ctx context.Context, userID uint, old, new string) error {
	user, err := s.User(ctx, userID)
	if err != nil {
		return err
	}
	if err := user.ValidatePassword(old); err != nil {
		return fmt.Errorf("old password validation failed: %v", err)
	}
	hashed, salt, err := hashPassword(new, s.saltKeySize, s.bcryptCost)
	if err != nil {
		return err
	}
	user.Salt = salt
	user.Password = hashed
	return s.saveUser(user)
}

func (s service) UpdateAdminRole(ctx context.Context, userID uint, isAdmin bool) error {
	user, err := s.User(ctx, userID)
	if err != nil {
		return err
	}
	user.Admin = isAdmin
	return s.saveUser(user)
}

func (s service) UpdateUserStatus(ctx context.Context, userID uint, password string, enabled bool) error {
	user, err := s.User(ctx, userID)
	if err != nil {
		return err
	}
	// TODO @groob
	// password validation
	user.Enabled = enabled
	return s.saveUser(user)
}

// saves user in datastore.
// doesn't need to be exposed to the transport
// the service should expose actions for modifying a user instead
func (s service) saveUser(user *kolide.User) error {
	return s.ds.SaveUser(user)
}

func userFromPayload(p kolide.UserPayload, keySize, cost int) (*kolide.User, error) {
	hashed, salt, err := hashPassword(*p.Password, keySize, cost)
	if err != nil {
		return nil, err
	}

	return &kolide.User{
		Username:           *p.Username,
		Email:              *p.Email,
		Admin:              falseIfNil(p.Admin),
		NeedsPasswordReset: falseIfNil(p.NeedsPasswordReset),
		Salt:               salt,
		Password:           hashed,
	}, nil
}

func hashPassword(plaintext string, keySize, cost int) ([]byte, string, error) {
	salt, err := generateRandomText(keySize)
	if err != nil {
		return nil, "", err
	}

	withSalt := []byte(fmt.Sprintf("%s%s", plaintext, salt))
	hashed, err := bcrypt.GenerateFromPassword(withSalt, cost)
	if err != nil {
		return nil, "", err
	}

	return hashed, salt, nil

}

// generateRandomText return a string generated by filling in keySize bytes with
// random data and then base64 encoding those bytes
func generateRandomText(keySize int) (string, error) {
	key := make([]byte, keySize)
	_, err := rand.Read(key)
	if err != nil {
		return "", err
	}
	return base64.StdEncoding.EncodeToString(key), nil
}

// helper to convert a bool pointer false
func falseIfNil(b *bool) bool {
	if b == nil {
		return false
	}
	return *b
}
